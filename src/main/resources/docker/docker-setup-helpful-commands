# docker commands that help in 
#  - container setup ( important memory setup, create needed database collections/tables/indexes, etc. )
#  - check the data with specific queries
#  - etc.

###############
# elasticsearch
###############
# start powershell on windows
$	open powershell

# start docker-desktop on wsl
wsl -d docker-desktop

# changed a vm.max_map_count value in order to fix ES error bootstrap checks failed
sysctl -w vm.max_map_count=262144

#################################

#########
# mongodb
#########
# login to mongoDB
$	mongo -u root -p example

# switch to wine database
$	use wine;

# create a user
$	db.createUser({user:"test",pwd:"test",roles:["readWrite","dbAdmin"]});

# create a collection
$	db.createCollection('wines');

# create indeces
$	db.wines.createIndex( {country :} );
$	db.wines.createIndex( {points :} );
$	db.wines.createIndex( {price :} );
$	db.wines.createIndex( {country :, points:} );

# show available collections
$	show collections;

# get all indexes for wines collection
$	db.wines.getIndexes();

# get max Id
$	db.wines.find().sort({id:-1}).limit(1);

###########################################

###########
# cassandra
###########
# run bash on cassandra container
$	docker exec -it cassandra_container bash
# start cqlsh tool
$	cqlsh -u cassandra -p cassandra

# create a keyspace  
$	CREATE KEYSPACE IF NOT EXISTS wines WITH replication={'class':'NetworkTopologyStrategy', 'datacenter1': '1'};

# create a table
$	CREATE TABLE wines.wine(
	  id bigint,
	  num int,
	  country varchar,
	  description varchar,
	  designation varchar,
	  points int,
	  price float,
	  province varchar,
	  region1 varchar,
	  region2 varchar,
	  variety varchar,
	  winery varchar,
	  PRIMARY KEY (id)
	);

# some helping commands
$	describe keyspaces;
$	describe tables;
$	select * from wines.wine;
#############################

############
# postgresql
############
# Firstly, connect with your favorite DB tool to the postgres database with user: root and password: root  

# create a DB schema
$	create schema wines;

# create a table
$	CREATE TABLE wines.wine(
	  id SERIAL,
	  num integer,
	  country text,
	  description text,
	  designation text,
	  points int,
	  price double precision,
	  province text,
	  region1 text,
	  region2 text,
	  variety text,
	  winery text,
	  PRIMARY KEY (id)
	);

# create a index
$	create index idx_wine_country_points on wines.wine(country,points);

# create another index
$	create index idx_wine_price on wines.wine(price);

#####################################################

########
# ksqldb
########
# start ksqldb-cli tool
$	docker exec -it ksqldb-cli ksql http://ksqldb-server:8088

# It tells ksqlDB to start all queries from the earliest point in each topic:
$	SET 'auto.offset.reset' = 'earliest';

# create a stream
$	CREATE STREAM s_wines (
	  id bigint key,
	  num int,
	  country VARCHAR,
	  description VARCHAR,
	  designation VARCHAR,
	  points int,
	  price double,
	  province VARCHAR,
	  region1 VARCHAR,
	  region2 VARCHAR,
	  variety VARCHAR,
	  winery VARCHAR
	) WITH (
		kafka_topic = 'wines',
		partitions =,
		value_format = 'DELIMITED'
	);
##################################

#######
# redis
#######
# start redis-cli tool
$	docker-compose run redisearch redis-cli -h redisearch

# add test data
$	HSET wine:0 num 0 country "Test" description "test" designation "test" points 0 price 0.0 province "test" region1 "test" region2 "test" variety "test" winery "test" flag 0
	HSET wine:-1 num -1 country "test2" description "test" designation "test" points 0 price 0.0 province "test" region1 "test" region2 "test" variety "test" winery "test" flag 0
	HSET wine:-2 num -2 country "test2" description "test" designation "test" points 0 price 0.0 province "test" region1 "test" region2 "test" variety "test" winery "test" flag 0
	HSET wine:-3 num -3 country "test" description "test" designation "test" points 0 price 0.0 province "test" region1 "test" region2 "test" variety "test" winery "test" flag 0
	HSET wine:-4 num -4 country "test" description "test" designation "test" points 0 price 0.0 province "test" region1 "test" region2 "test" variety "test" winery "test" flag 0
    HSET wine:-5 num -5 country "Test" description "test" designation "test" points -1 price -1.0 province "test" region1 "test" region2 "test" variety "test" winery "test" flag 0

# show all keys
$	keys wine*

# create the index
$	FT.CREATE idx:wine on hash prefix 1 "wine:" SCHEMA flag NUMERIC country TAG CASESENSITIVE points NUMERIC sortable price NUMERIC sortable 
    

# index information
$	FT.INFO idx:wine

# search by a field
$	FT.SEARCH idx:wine "Bulgaria"
$	FT.SEARCH idx:wine * FILTER points 0 0
$	FT.SEARCH idx:wine "@country:{Bulgaria}"

# search by two fields
$	FT.SEARCH idx:wine "@country:Bulgaria  @points:[100]"

# update one field
$	HSET wine:-1 country "Test"

# delete a key -2 in a second
$	EXPIRE wine:-2
# delete keys -4 and -5
$	del wine:-4 wine:-5

# count by field
$	FT.SEARCH idx:wine @country:{test} LIMIT 0 0

# an example with many aggregation functions just in a query
$	FT.AGGREGATE idx:wine * GROUPBY 1 @flag REDUCE MIN 1 price as min_price REDUCE MAX 1 price as max_price REDUCE AVG 1 price as avg_price

